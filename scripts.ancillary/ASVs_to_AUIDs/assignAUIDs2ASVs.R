#!/bin/env Rscript

##
## Pass in a table of full paths to ASV files from DADA2 (column 1) and tags
## (column 2).  E.g. the asvs.noChimera.fasta generated by the pipeline.  This
## script will determine which ASVs are unique and assign ID's and md5's to
## them.
##


usageStr <- "
Usage:
    assignAUIDs2ASVs.R  listOfAsvFastas.txt  [options]

Pass a table (.tsv) of full paths to FASTA files such as ASVs from DADA2 (column
1) and descriptive tags for each set (column 2). The tag can be anything but
short is best and you can structure it, e.g. sample Arctic2017:DNA:Filt0.2.

The script will assign AUIDs (ASV unique id's) to all sequences and output a
table (asv2auid.tsv) that includes the AUIDs, sequence md5's, the sequences
themselves, the tags, and in which 'tags' the sequence was detected so that you
can identify sequences found across locations, size fractions, etc. (depending
on the information in your tags).

Important difference between AUIDs and md5s:
   AUIDs: Short and legible.  Uniquely assigned to each sequence **within a set
          of FASTA files**.  Do not mix AUIDs from different invocations of this
          script!

   md5s: Long and illegible.  Unique* to each sequence. The md5s can be compared
         across invocations of this script. (*It is _extremely_ unlikely that two
         distinct sequences would have the same md5 checksum.)

Options:
  -fasta: Write out a fasta file of the AUIDs with definition lines that
          indicate the tags associated with the AUID (e.g. to see which AUIDs
          were identified across locations).

  -length=min,max: Only output sequences such that min <= length <= max.
          Spaces not allowed in this parameter.

"
outFile  <- 'asv2auid.tsv'
outFasta <- 'asv2auid.fasta' # optional

## The assignment of AUID identifiers should be completely deterministic for a
## given input list of FASTA files. However, it is good practice to set the
## random seed (even though nothing about this script should be impacted by
## this).
set.seed(7675308)

args <- commandArgs(trailingOnly=T)
if (length(args) == 0) {
    cat(usageStr)
    quit(save='no')
}
asvFastaPathsFile <- args[1]
if (!file.exists(asvFastaPathsFile)) {
    cat(usageStr)
    stop(asvFastaPathsFile," does not exist.")
}
if (file.exists(outFile) || file.exists(outFasta)) {
    stop(outFile,"and/or",outFile,"already exist.")
}

cat("Loading ASV fastas...\n")
asvFastaPaths <- read.table(asvFastaPathsFile, sep="\t", header=F)
stopifnot(ncol(asvFastaPaths) == 2)
colnames(asvFastaPaths) <- c('Path','Tag')
stopifnot(table(asvFastaPaths$Path) == 1)  # Each path occurs exactly once

cat("Loading libraries...\n")
suppressMessages(library(ShortRead))
suppressMessages(library(digest))

cat("Mapping ASVs to AUIDs...\n")
asv2auid <- data.frame()
for (i in 1:nrow(asvFastaPaths)) {
    seq <- readFasta(asvFastaPaths$Path[i])
    if (length(seq) == 0) { stop(asvFastaPaths$Path[i]," has no sequences.") }
    ## The MD5's are the values. Names are the ASV sequences.
    md5s <- sapply(as.character(sread(seq)), digest, algo='md5')
    aids <- as.character(id(seq))  # same order as md5s
    ## If the fastas are from the DADA2 pipeline, then Source encodes the
    ## processing group. However, processing group structure will differ across
    ## data sets so do not parse it. That is why we have the tags
    df <- data.frame(Source = asvFastaPaths$Path[i],
                     Tag    = asvFastaPaths$Tag[i],
                     ASVid  = aids,
                     md5    = as.character(md5s),
                     Length = width(seq),
                     Seq =    names(md5s))
    asv2auid <- rbind(asv2auid,df)
}
rm(i,seq,md5s,aids,df)

## Now figure out which ASVs have identical UIDs and thus identical sequences
## (assuming no md5 collisions).  "AUID" meaning ASV unique ID.
asv2auid$AUID <- paste0('AUID.',match(asv2auid$md5, unique(asv2auid$md5)))

## Prefered column order
asv2auid <- asv2auid[,c('Source','ASVid','AUID','md5','Tag','Length','Seq')]

cat("There were", nrow(asv2auid), "ASV's assigned to",
    length(unique(asv2auid$AUID)), "AUIDs (the number of distinct sequences).\n")

## Handle optional length range filter.
idx <- grep('-length=[0-9]+,[0-9]+', args)
if (length(idx) > 0) {
    min <- as.integer(sub('-length=([0-9]+),.*','\\1',args[idx]))
    max <- as.integer(sub('-length=[0-9]+,([0-9]+)','\\1',args[idx]))
    ss <- subset(asv2auid, Length>=min & Length<=max)
    cat("After filtering for sequences between",min,"and",max,"nt,",
        "there are", length(unique(ss$AUID)), "AUIDs.\n")
    asv2auid <- ss
    rm(ss)
}

## Write out asv2auid
cat("Writing",outFile,"...\n")
write.table(asv2auid, file=outFile, sep="\t", quote=F)


## If asked, write out fasta file
if (length(grep('-fasta', args)) != 0) {
    cat("Preparing descriptions for FASTA...\n")
    ## For each AUID (col 1), concatenate all the associated tags (removing
    ## duplicates).  Takes up to a few seconds
    descTab <- aggregate(asv2auid$Tag, by=list(AUID=asv2auid$AUID),
                         function(v) paste(unique(v), collapse='; '))
    colnames(descTab) <- c('AUID','Desc')
    ## Now get the sequences.
    descTab$Seq <- asv2auid[match(descTab$AUID, asv2auid$AUID), 'Seq']
    ## Quick check that descTab and asv2auid agree
    idx <- sample(1:nrow(descTab), min(30,nrow(descTab)))
    for (i in idx) {
        stopifnot( asv2auid[match(descTab[i,'AUID'],asv2auid$AUID),'Seq'] == descTab[i,'Seq'] )
    }
    cat("Writing FASTA",outFasta,"...\n")
    writeLines(paste0('>',descTab$AUID,' ',descTab$Desc,'\n',descTab$Seq,'\n'), outFasta)
}

cat("Done!")
quit(save='no')
